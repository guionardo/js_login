/* eslint-disable no-console */

/**
 * Classe de controle de logins, com conexão ao back-end para validação e uso de token
 */
class WebLogin {
  /**
   * Constructor
   * @param {string} loginUrl URL de destino no backend
   * @param {*} callBack função que será chamada a cada evento
   */
  constructor(loginUrl = 'login.json', callBack = null) {
    this.wlConsts = {
      cookieName: 'loginKey',
      minDate: 'Thu, 01 Jan 1970 00:00:00 UTC',
      propToken: 'token',
      propExpires: 'expires',
      propData: 'data',
      loginStatus_not_init: -1,
      loginStatus_fetching: 0,
      loginStatus_login_ok: 1,
      loginStatus_login_error: 2,
      cookiesDisabled: 'COOKIES NEED TO BE ACTIVE ON THIS BROWSER',
      browserDisabled: 'BROWSER DISABLED',
      cookieLoaded: 'AUTH COOKIE OK',
      cookieDataInvalid: 'AUTH COOKIE DATA ERROR',
      cookieLoadException: 'COOKIE LOAD EXCEPTION',
      serverLogout: 'SERVER LOGOUT'
    }
    Object.freeze(this.wlConsts);

    // Nome do cookie
    this.CookieName = this.wlConsts.cookieName;

    // Token recebido do servidor
    this.ServerToken = '';

    // URL para request de login ao servidor
    this.LoginURL = loginUrl;

    // Validade do token (valor em segundos desde 01/01/1970)
    this.TokenExpires = 0;

    // Dados extra, enviados pelo servidor auth
    this.Data = false;

    // Função de retorno de status
    this.CallBack = callBack;

    // Status do login
    // -1 = Não inicializado
    // 0 = Fetching (obtendo a partir do servidor)
    // 1 = Login OK
    // 2 = Erro de login

    this.status = this.wlConsts.loginStatus_not_init;
    this.lastmessage = '';
    this.cookie_load();
  }

  /**
   * Envia a mensagem para o método call-back, incluindo as informações Data enviadas pelo servidor auth
   * @param {*} msg 
   */
  doCallBack(msg) {
    this.lastmessage = msg;
    if (this.CallBack != null) {
      this.CallBack(msg, this.Data);
    }
  }

  /**
   * Obtém o valor de uma propriedade do objeto ou um valor default se não existir.
   * @param {} object 
   * @param {*} property 
   * @param {*} defaultValue 
   */
  getProp(object, property, defaultValue = false) {
    object.hasOwnProperty(property) ? object[property] : defaultValue;
  }
  /**
   * Carrega as informações de login (token e validade) a partir do cookie
   */
  cookie_load() {
    if (typeof navigator != 'undefined' && navigator.cookieEnabled) {
      this.doCallBack(this.wlConsts.cookiesDisabled);
      return;
    }
    if (typeof document == 'undefined') {
      this.doCallBack(this.wlConsts.browserDisabled);
      return;
    }
    let ca = decodeURIComponent(document.cookie).split(';');
    let cookie = '';
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i].trim();

      if (c.indexOf(this.CookieName) == 0) {
        cookie = c.substring(this.CookieName.length + 1, c.length);
        break;
      }
    }
    if (cookie.length > 0) {
      try {
        let json = JSON.parse(atob(cookie));
        let token = this.getProp(json, this.wlConsts.propToken);
        let expires = this.getProp(json, this.wlConsts.propExpires);
        let data = this.getProp(json, this.wlConsts.propData);
        if (token && expires) {
          this.ServerToken = json.token;
          this.TokenExpires = this.parseExpires(json.expires);
          this.Data = data;
          this.doCallBack(this.wlConsts.cookieLoaded);
          return true;
        }

        // Erro no token
        this.doCallBack(this.wlConsts.cookieDataInvalid);

      } catch (e) {
        this.cookie_release();
        this.doCallBack(this.wlConsts.cookieLoadException + ' ' + e.message);
      }
    } else {
      // Erro no token
      this.cookie_release();
      this.doCallBack(this.wlConsts.cookieDataInvalid);
    }
    return false;
  }
  /**
   * Libera o cookie de login
   */
  cookie_release() {
    this.TokenExpires = 0;
    document.cookie = this.cookieName + '=; expires=' + new Date(0).toUTCString() + '; path=/;';
  }

  /**
   * Trata uma informação de expiração retornando um objeto Date
   * @param {*} expires 
   */
  parseExpires(expires) {
    var d;
    if (typeof (expires) === 'string') {
      try {
        d = new Date(Date.parse(expires));
        return d;
      } catch (e) { d = 0; }
    } else if (typeof (expires) === 'number') {
      try {
        d = new Date(expires);
        return d;
      } catch (e) { d = 0; }
    }

    return Date.parse(this.wlConsts.minDate);
  }

  cookie_save() {
    if (this.status == 1) {
      var exp = new Date(this.TokenExpires);

      document.cookie = this.CookieName + "=" + btoa(JSON.stringify({ token: this.ServerToken, expires: this.TokenExpires })) +
        "; expires=" + exp.toUTCString() + ";";
    }
  }

  parseJSONLogin(json) {
    this.Data = {};
    this.ServerToken = false;
    this.TokenExpires = 0;
    if (typeof (json) === 'string') {
      json = JSON.parse(json);
    }
    if (this.CheckToken(json, 'token') && this.CheckToken(json, 'expires') && this.CheckToken(json, 'message')) {
      // Retorno normal
      this.Data = this.CheckToken('data', {});
      if (json.expires == 0) {
        // Login falhou        
        this.Data.Message = json.message;
        this.cookie_release();
        this.status = this.wlConsts.loginStatus_login_error;
        this.doCallBack(this.wlConsts.loginError);
      } else {
        // Login Ok
        this.ServerToken = json.token;
        this.TokenExpires = this.parseExpires(json.expires);
        this.status = this.wlConsts.loginStatus_login_ok;
        this.cookie_save();
        this.doCallBack(this.wlConsts.loginOK);
      }
    } else {
      // Erro na leitura do login      
      this.status = this.wlConsts.loginStatus_login_error;
      this.doCallBack(this.wlConsts.loginStatus_login_error);
    }
  }

  fetchJSON(url, callBack, method = "GET", params = false) {
    if (self.fetch) {
      var ops = { method: method };
      if (method == "POST") {
        ops.headers = new Headers({
          'Content-Type': 'application/x-www-form-urlencoded', // <-- Specifying the Content-Type
        });
      }
      if (params) {
        ops.body = params;
      }
      fetch(url, ops)
        .then(response => {
          response.text()
            .then(result => {
              try {
                var json = JSON.parse(result);
                callBack(true, json);
              } catch (e) {
                callBack(false, "");
              }
            })
        });
    } else {
      callBack(false, "");
    }
  }
  /**
   * Obtém as informações de login do back-end
   */
  DoLogin(userName, userPassword) {
    this.fetchJSON(this.LoginURL, (success, json) => {
      if (success) {
        this.parseJSONLogin(json);
      }
    }, "POST", "login=" + userName + "&pass=" + userPassword);
  }

  DoLogout() {
    if (this.ServerToken) {
      this.fetchJSON(this.LoginURL, (success) => {
        this.ServerToken = "";
        this.TokenExpires = 0;
        this.cookie_release();
        this.doCallBack("Logout:" + success);
      }, "GET", "logout=" + this.ServerToken)
    }
  }

  CheckToken() {
    if (this.ServerToken) {
      this.fetchJSON(this.LoginURL, (success, json) => {
        if (success) {
          this.TokenExpires = Date.parse(json.expires);
          document.cookie = this.cookieName + "=; expires='" + json.expires + ";'";
        } else {
          this.ServerToken = false;
          this.TokenExpires = 0;
          this.cookie_release();
          this.doCallBack(this.wlConsts.serverLogout);
        }
      })
    }
  }



}


let wl = new WebLogin();
console.log(wl.parseExpires(50));
console.log(wl.parseExpires('Thu, 01 Jan 1970 00:00:00 UTC'));
/* eslint-disable no-console */
const http = require('http')
const uuid = require('uuid/v1')
const fs = require('fs')

const port = 3000
const ip = 'localhost'
const url = require('url')
const users = {
  "Guionardo": {
    pass: "1234", args: { nome: "Guionardo Furlan", idade: 42 }
  },
  "Marines": {
    pass: "5678", args: { nome: "Marines dos Santos Furlan", idade: 41 }
  }
}

const tokens = {}

const server = http.createServer((req, res) => {
  var url_parts = url.parse(req.url, true);

  var parts = url_parts.query;
  var resposta = {
    OK: false,
    MSG: '',
    FUNC: '',
    TOKEN: '',
    USERDATA: {}
  }

  let func = (typeof (parts['login']) != 'undefined' ? 'login' :
    typeof (parts['logout']) != 'undefined' ? 'logout' :
      typeof (parts['check']) != 'undefined' ? 'check' : false);

  if (!func) {
    var arquivo = '.' + url_parts.path;
    if (arquivo == './') { arquivo = './index.html'; }
    console.log(arquivo);
    fs.exists(arquivo, (exists) => {
      if (!exists) {
        return;
      }
      fs.readFile(arquivo, function (err, html) {
        if (err) {
          console.error(err.message);
          res.end();
          return;
        }
        if (arquivo.substr(-3) === ".js") {
          res.writeHead(200, { "Content-Type": "text/javascript" })
        } else {
          res.writeHead(200, { "Content-Type": "text/html" });
        }
        res.write(html);
        res.end();
      })
    })

    return;
  }

  resposta.FUNC = func;

  switch (func) {
    case 'login':
      //### Solicitação de login para o usuário com senha (POST)
      //(url)?login&user=userName&pass=userPassword
      if (parts['user'] === undefined) {
        resposta.MSG = 'PARAMETER NOT FOUND user'
      } else if (parts['pass'] === undefined) {
        resposta.MSG = 'PARAMETER NOT FOUND pass'
      } else if (users[parts['user']] === undefined) {
        resposta.MSG = 'USER NOT FOUND ' + parts['user']
      } else if (users[parts['user']].pass != parts['pass']) {
        resposta.MSG = 'PASSWORD ERROR'
      } else {
        var token = uuid();
        tokens[token] = parts['user'];
        resposta.MSG = 'OK';
        resposta.OK = true;
        resposta.TOKEN = token;
        resposta.USERDATA = users[tokens[token]].args;
      }
      break;
    case 'logout':
      //### Solicitação de logout para o usuário (GET)
      //(url)?logout&token=loginToken
      if (parts['token'] === undefined) {
        resposta.MSG = 'PARAMETER NOT FOUND token'
      } else
        if (tokens[parts['token']] === undefined ||
          tokens[parts['token']] === null) {
          resposta.MSG = 'TOKEN NOT FOUND ' + parts['token']
        } else {
          tokens[parts['token']] = null
          resposta.MSG = 'TOKEN OK';
          resposta.TOKEN = parts['token']
          resposta.OK = true;
        }

      break;
    case 'check':
      //### Solicitação de validade do token (GET)
      //(url)?check&token=loginToken
      if (parts['token'] === undefined) {
        resposta.MSG = 'PARAMETER NOT FOUND token'
      } else
        if (tokens[parts['token']] === undefined) {
          resposta.MSG = 'TOKEN NOT FOUND ' + parts['token']
        } else {
          resposta.TOKEN = parts['token']
          resposta.MSG = 'TOKEN OK';
          resposta.OK = true;
          resposta.USERDATA = users[tokens[parts['token']]].args;
        }

      break;
    default:

  }


  res.end(JSON.stringify(resposta));
})


server.listen(port, ip, () => {
  console.log(`Servidor rodando em http://${ip}:${port}`);
})

/* eslint-disable no-console */
function testDate(){
  var d = Date.parse('Thu, 01 Jan 1970 00:00:00 UTC');
  console.log(d);  
  let e = new Date(d);
  console.log(e.toUTCString());

  d = Date.parse('Tue, 26 Mar 2019 14:34:00 UTC');
  console.log(d);  
  e = new Date(d);
  console.log(e.toUTCString())

  
  d = new Date(1553610840000);
  console.log(d);  
  e = new Date(d);
  console.log(e.toUTCString())
}

testDate();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxvZ2luLmpzIiwic2VydmVyLmpzIiwidGVzdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYXBwLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuXHJcbi8qKlxyXG4gKiBDbGFzc2UgZGUgY29udHJvbGUgZGUgbG9naW5zLCBjb20gY29uZXjDo28gYW8gYmFjay1lbmQgcGFyYSB2YWxpZGHDp8OjbyBlIHVzbyBkZSB0b2tlblxyXG4gKi9cclxuY2xhc3MgV2ViTG9naW4ge1xyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvZ2luVXJsIFVSTCBkZSBkZXN0aW5vIG5vIGJhY2tlbmRcclxuICAgKiBAcGFyYW0geyp9IGNhbGxCYWNrIGZ1bsOnw6NvIHF1ZSBzZXLDoSBjaGFtYWRhIGEgY2FkYSBldmVudG9cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihsb2dpblVybCA9ICdsb2dpbi5qc29uJywgY2FsbEJhY2sgPSBudWxsKSB7XHJcbiAgICB0aGlzLndsQ29uc3RzID0ge1xyXG4gICAgICBjb29raWVOYW1lOiAnbG9naW5LZXknLFxyXG4gICAgICBtaW5EYXRlOiAnVGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVEMnLFxyXG4gICAgICBwcm9wVG9rZW46ICd0b2tlbicsXHJcbiAgICAgIHByb3BFeHBpcmVzOiAnZXhwaXJlcycsXHJcbiAgICAgIHByb3BEYXRhOiAnZGF0YScsXHJcbiAgICAgIGxvZ2luU3RhdHVzX25vdF9pbml0OiAtMSxcclxuICAgICAgbG9naW5TdGF0dXNfZmV0Y2hpbmc6IDAsXHJcbiAgICAgIGxvZ2luU3RhdHVzX2xvZ2luX29rOiAxLFxyXG4gICAgICBsb2dpblN0YXR1c19sb2dpbl9lcnJvcjogMixcclxuICAgICAgY29va2llc0Rpc2FibGVkOiAnQ09PS0lFUyBORUVEIFRPIEJFIEFDVElWRSBPTiBUSElTIEJST1dTRVInLFxyXG4gICAgICBicm93c2VyRGlzYWJsZWQ6ICdCUk9XU0VSIERJU0FCTEVEJyxcclxuICAgICAgY29va2llTG9hZGVkOiAnQVVUSCBDT09LSUUgT0snLFxyXG4gICAgICBjb29raWVEYXRhSW52YWxpZDogJ0FVVEggQ09PS0lFIERBVEEgRVJST1InLFxyXG4gICAgICBjb29raWVMb2FkRXhjZXB0aW9uOiAnQ09PS0lFIExPQUQgRVhDRVBUSU9OJyxcclxuICAgICAgc2VydmVyTG9nb3V0OiAnU0VSVkVSIExPR09VVCdcclxuICAgIH1cclxuICAgIE9iamVjdC5mcmVlemUodGhpcy53bENvbnN0cyk7XHJcblxyXG4gICAgLy8gTm9tZSBkbyBjb29raWVcclxuICAgIHRoaXMuQ29va2llTmFtZSA9IHRoaXMud2xDb25zdHMuY29va2llTmFtZTtcclxuXHJcbiAgICAvLyBUb2tlbiByZWNlYmlkbyBkbyBzZXJ2aWRvclxyXG4gICAgdGhpcy5TZXJ2ZXJUb2tlbiA9ICcnO1xyXG5cclxuICAgIC8vIFVSTCBwYXJhIHJlcXVlc3QgZGUgbG9naW4gYW8gc2Vydmlkb3JcclxuICAgIHRoaXMuTG9naW5VUkwgPSBsb2dpblVybDtcclxuXHJcbiAgICAvLyBWYWxpZGFkZSBkbyB0b2tlbiAodmFsb3IgZW0gc2VndW5kb3MgZGVzZGUgMDEvMDEvMTk3MClcclxuICAgIHRoaXMuVG9rZW5FeHBpcmVzID0gMDtcclxuXHJcbiAgICAvLyBEYWRvcyBleHRyYSwgZW52aWFkb3MgcGVsbyBzZXJ2aWRvciBhdXRoXHJcbiAgICB0aGlzLkRhdGEgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBGdW7Dp8OjbyBkZSByZXRvcm5vIGRlIHN0YXR1c1xyXG4gICAgdGhpcy5DYWxsQmFjayA9IGNhbGxCYWNrO1xyXG5cclxuICAgIC8vIFN0YXR1cyBkbyBsb2dpblxyXG4gICAgLy8gLTEgPSBOw6NvIGluaWNpYWxpemFkb1xyXG4gICAgLy8gMCA9IEZldGNoaW5nIChvYnRlbmRvIGEgcGFydGlyIGRvIHNlcnZpZG9yKVxyXG4gICAgLy8gMSA9IExvZ2luIE9LXHJcbiAgICAvLyAyID0gRXJybyBkZSBsb2dpblxyXG5cclxuICAgIHRoaXMuc3RhdHVzID0gdGhpcy53bENvbnN0cy5sb2dpblN0YXR1c19ub3RfaW5pdDtcclxuICAgIHRoaXMubGFzdG1lc3NhZ2UgPSAnJztcclxuICAgIHRoaXMuY29va2llX2xvYWQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVudmlhIGEgbWVuc2FnZW0gcGFyYSBvIG3DqXRvZG8gY2FsbC1iYWNrLCBpbmNsdWluZG8gYXMgaW5mb3JtYcOnw7VlcyBEYXRhIGVudmlhZGFzIHBlbG8gc2Vydmlkb3IgYXV0aFxyXG4gICAqIEBwYXJhbSB7Kn0gbXNnIFxyXG4gICAqL1xyXG4gIGRvQ2FsbEJhY2sobXNnKSB7XHJcbiAgICB0aGlzLmxhc3RtZXNzYWdlID0gbXNnO1xyXG4gICAgaWYgKHRoaXMuQ2FsbEJhY2sgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLkNhbGxCYWNrKG1zZywgdGhpcy5EYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idMOpbSBvIHZhbG9yIGRlIHVtYSBwcm9wcmllZGFkZSBkbyBvYmpldG8gb3UgdW0gdmFsb3IgZGVmYXVsdCBzZSBuw6NvIGV4aXN0aXIuXHJcbiAgICogQHBhcmFtIHt9IG9iamVjdCBcclxuICAgKiBAcGFyYW0geyp9IHByb3BlcnR5IFxyXG4gICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFxyXG4gICAqL1xyXG4gIGdldFByb3Aob2JqZWN0LCBwcm9wZXJ0eSwgZGVmYXVsdFZhbHVlID0gZmFsc2UpIHtcclxuICAgIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgPyBvYmplY3RbcHJvcGVydHldIDogZGVmYXVsdFZhbHVlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDYXJyZWdhIGFzIGluZm9ybWHDp8O1ZXMgZGUgbG9naW4gKHRva2VuIGUgdmFsaWRhZGUpIGEgcGFydGlyIGRvIGNvb2tpZVxyXG4gICAqL1xyXG4gIGNvb2tpZV9sb2FkKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5kb0NhbGxCYWNrKHRoaXMud2xDb25zdHMuY29va2llc0Rpc2FibGVkKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aGlzLmRvQ2FsbEJhY2sodGhpcy53bENvbnN0cy5icm93c2VyRGlzYWJsZWQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgY2EgPSBkZWNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuY29va2llKS5zcGxpdCgnOycpO1xyXG4gICAgbGV0IGNvb2tpZSA9ICcnO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgYyA9IGNhW2ldLnRyaW0oKTtcclxuXHJcbiAgICAgIGlmIChjLmluZGV4T2YodGhpcy5Db29raWVOYW1lKSA9PSAwKSB7XHJcbiAgICAgICAgY29va2llID0gYy5zdWJzdHJpbmcodGhpcy5Db29raWVOYW1lLmxlbmd0aCArIDEsIGMubGVuZ3RoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNvb2tpZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKGF0b2IoY29va2llKSk7XHJcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5nZXRQcm9wKGpzb24sIHRoaXMud2xDb25zdHMucHJvcFRva2VuKTtcclxuICAgICAgICBsZXQgZXhwaXJlcyA9IHRoaXMuZ2V0UHJvcChqc29uLCB0aGlzLndsQ29uc3RzLnByb3BFeHBpcmVzKTtcclxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0UHJvcChqc29uLCB0aGlzLndsQ29uc3RzLnByb3BEYXRhKTtcclxuICAgICAgICBpZiAodG9rZW4gJiYgZXhwaXJlcykge1xyXG4gICAgICAgICAgdGhpcy5TZXJ2ZXJUb2tlbiA9IGpzb24udG9rZW47XHJcbiAgICAgICAgICB0aGlzLlRva2VuRXhwaXJlcyA9IHRoaXMucGFyc2VFeHBpcmVzKGpzb24uZXhwaXJlcyk7XHJcbiAgICAgICAgICB0aGlzLkRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgdGhpcy5kb0NhbGxCYWNrKHRoaXMud2xDb25zdHMuY29va2llTG9hZGVkKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXJybyBubyB0b2tlblxyXG4gICAgICAgIHRoaXMuZG9DYWxsQmFjayh0aGlzLndsQ29uc3RzLmNvb2tpZURhdGFJbnZhbGlkKTtcclxuXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aGlzLmNvb2tpZV9yZWxlYXNlKCk7XHJcbiAgICAgICAgdGhpcy5kb0NhbGxCYWNrKHRoaXMud2xDb25zdHMuY29va2llTG9hZEV4Y2VwdGlvbiArICcgJyArIGUubWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEVycm8gbm8gdG9rZW5cclxuICAgICAgdGhpcy5jb29raWVfcmVsZWFzZSgpO1xyXG4gICAgICB0aGlzLmRvQ2FsbEJhY2sodGhpcy53bENvbnN0cy5jb29raWVEYXRhSW52YWxpZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIExpYmVyYSBvIGNvb2tpZSBkZSBsb2dpblxyXG4gICAqL1xyXG4gIGNvb2tpZV9yZWxlYXNlKCkge1xyXG4gICAgdGhpcy5Ub2tlbkV4cGlyZXMgPSAwO1xyXG4gICAgZG9jdW1lbnQuY29va2llID0gdGhpcy5jb29raWVOYW1lICsgJz07IGV4cGlyZXM9JyArIG5ldyBEYXRlKDApLnRvVVRDU3RyaW5nKCkgKyAnOyBwYXRoPS87JztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYXRhIHVtYSBpbmZvcm1hw6fDo28gZGUgZXhwaXJhw6fDo28gcmV0b3JuYW5kbyB1bSBvYmpldG8gRGF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gZXhwaXJlcyBcclxuICAgKi9cclxuICBwYXJzZUV4cGlyZXMoZXhwaXJlcykge1xyXG4gICAgdmFyIGQ7XHJcbiAgICBpZiAodHlwZW9mIChleHBpcmVzKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBkID0gbmV3IERhdGUoRGF0ZS5wYXJzZShleHBpcmVzKSk7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHsgZCA9IDA7IH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIChleHBpcmVzKSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBkID0gbmV3IERhdGUoZXhwaXJlcyk7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHsgZCA9IDA7IH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRGF0ZS5wYXJzZSh0aGlzLndsQ29uc3RzLm1pbkRhdGUpO1xyXG4gIH1cclxuXHJcbiAgY29va2llX3NhdmUoKSB7XHJcbiAgICBpZiAodGhpcy5zdGF0dXMgPT0gMSkge1xyXG4gICAgICB2YXIgZXhwID0gbmV3IERhdGUodGhpcy5Ub2tlbkV4cGlyZXMpO1xyXG5cclxuICAgICAgZG9jdW1lbnQuY29va2llID0gdGhpcy5Db29raWVOYW1lICsgXCI9XCIgKyBidG9hKEpTT04uc3RyaW5naWZ5KHsgdG9rZW46IHRoaXMuU2VydmVyVG9rZW4sIGV4cGlyZXM6IHRoaXMuVG9rZW5FeHBpcmVzIH0pKSArXHJcbiAgICAgICAgXCI7IGV4cGlyZXM9XCIgKyBleHAudG9VVENTdHJpbmcoKSArIFwiO1wiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcGFyc2VKU09OTG9naW4oanNvbikge1xyXG4gICAgdGhpcy5EYXRhID0ge307XHJcbiAgICB0aGlzLlNlcnZlclRva2VuID0gZmFsc2U7XHJcbiAgICB0aGlzLlRva2VuRXhwaXJlcyA9IDA7XHJcbiAgICBpZiAodHlwZW9mIChqc29uKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5DaGVja1Rva2VuKGpzb24sICd0b2tlbicpICYmIHRoaXMuQ2hlY2tUb2tlbihqc29uLCAnZXhwaXJlcycpICYmIHRoaXMuQ2hlY2tUb2tlbihqc29uLCAnbWVzc2FnZScpKSB7XHJcbiAgICAgIC8vIFJldG9ybm8gbm9ybWFsXHJcbiAgICAgIHRoaXMuRGF0YSA9IHRoaXMuQ2hlY2tUb2tlbignZGF0YScsIHt9KTtcclxuICAgICAgaWYgKGpzb24uZXhwaXJlcyA9PSAwKSB7XHJcbiAgICAgICAgLy8gTG9naW4gZmFsaG91ICAgICAgICBcclxuICAgICAgICB0aGlzLkRhdGEuTWVzc2FnZSA9IGpzb24ubWVzc2FnZTtcclxuICAgICAgICB0aGlzLmNvb2tpZV9yZWxlYXNlKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLndsQ29uc3RzLmxvZ2luU3RhdHVzX2xvZ2luX2Vycm9yO1xyXG4gICAgICAgIHRoaXMuZG9DYWxsQmFjayh0aGlzLndsQ29uc3RzLmxvZ2luRXJyb3IpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIExvZ2luIE9rXHJcbiAgICAgICAgdGhpcy5TZXJ2ZXJUb2tlbiA9IGpzb24udG9rZW47XHJcbiAgICAgICAgdGhpcy5Ub2tlbkV4cGlyZXMgPSB0aGlzLnBhcnNlRXhwaXJlcyhqc29uLmV4cGlyZXMpO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy53bENvbnN0cy5sb2dpblN0YXR1c19sb2dpbl9vaztcclxuICAgICAgICB0aGlzLmNvb2tpZV9zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5kb0NhbGxCYWNrKHRoaXMud2xDb25zdHMubG9naW5PSyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEVycm8gbmEgbGVpdHVyYSBkbyBsb2dpbiAgICAgIFxyXG4gICAgICB0aGlzLnN0YXR1cyA9IHRoaXMud2xDb25zdHMubG9naW5TdGF0dXNfbG9naW5fZXJyb3I7XHJcbiAgICAgIHRoaXMuZG9DYWxsQmFjayh0aGlzLndsQ29uc3RzLmxvZ2luU3RhdHVzX2xvZ2luX2Vycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZldGNoSlNPTih1cmwsIGNhbGxCYWNrLCBtZXRob2QgPSBcIkdFVFwiLCBwYXJhbXMgPSBmYWxzZSkge1xyXG4gICAgaWYgKHNlbGYuZmV0Y2gpIHtcclxuICAgICAgdmFyIG9wcyA9IHsgbWV0aG9kOiBtZXRob2QgfTtcclxuICAgICAgaWYgKG1ldGhvZCA9PSBcIlBPU1RcIikge1xyXG4gICAgICAgIG9wcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCAvLyA8LS0gU3BlY2lmeWluZyB0aGUgQ29udGVudC1UeXBlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgIG9wcy5ib2R5ID0gcGFyYW1zO1xyXG4gICAgICB9XHJcbiAgICAgIGZldGNoKHVybCwgb3BzKVxyXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgIHJlc3BvbnNlLnRleHQoKVxyXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGNhbGxCYWNrKHRydWUsIGpzb24pO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxCYWNrKGZhbHNlLCBcIlwiKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsQmFjayhmYWxzZSwgXCJcIik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE9idMOpbSBhcyBpbmZvcm1hw6fDtWVzIGRlIGxvZ2luIGRvIGJhY2stZW5kXHJcbiAgICovXHJcbiAgRG9Mb2dpbih1c2VyTmFtZSwgdXNlclBhc3N3b3JkKSB7XHJcbiAgICB0aGlzLmZldGNoSlNPTih0aGlzLkxvZ2luVVJMLCAoc3VjY2VzcywganNvbikgPT4ge1xyXG4gICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgIHRoaXMucGFyc2VKU09OTG9naW4oanNvbik7XHJcbiAgICAgIH1cclxuICAgIH0sIFwiUE9TVFwiLCBcImxvZ2luPVwiICsgdXNlck5hbWUgKyBcIiZwYXNzPVwiICsgdXNlclBhc3N3b3JkKTtcclxuICB9XHJcblxyXG4gIERvTG9nb3V0KCkge1xyXG4gICAgaWYgKHRoaXMuU2VydmVyVG9rZW4pIHtcclxuICAgICAgdGhpcy5mZXRjaEpTT04odGhpcy5Mb2dpblVSTCwgKHN1Y2Nlc3MpID0+IHtcclxuICAgICAgICB0aGlzLlNlcnZlclRva2VuID0gXCJcIjtcclxuICAgICAgICB0aGlzLlRva2VuRXhwaXJlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5jb29raWVfcmVsZWFzZSgpO1xyXG4gICAgICAgIHRoaXMuZG9DYWxsQmFjayhcIkxvZ291dDpcIiArIHN1Y2Nlc3MpO1xyXG4gICAgICB9LCBcIkdFVFwiLCBcImxvZ291dD1cIiArIHRoaXMuU2VydmVyVG9rZW4pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBDaGVja1Rva2VuKCkge1xyXG4gICAgaWYgKHRoaXMuU2VydmVyVG9rZW4pIHtcclxuICAgICAgdGhpcy5mZXRjaEpTT04odGhpcy5Mb2dpblVSTCwgKHN1Y2Nlc3MsIGpzb24pID0+IHtcclxuICAgICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgdGhpcy5Ub2tlbkV4cGlyZXMgPSBEYXRlLnBhcnNlKGpzb24uZXhwaXJlcyk7XHJcbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSB0aGlzLmNvb2tpZU5hbWUgKyBcIj07IGV4cGlyZXM9J1wiICsganNvbi5leHBpcmVzICsgXCI7J1wiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLlNlcnZlclRva2VuID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLlRva2VuRXhwaXJlcyA9IDA7XHJcbiAgICAgICAgICB0aGlzLmNvb2tpZV9yZWxlYXNlKCk7XHJcbiAgICAgICAgICB0aGlzLmRvQ2FsbEJhY2sodGhpcy53bENvbnN0cy5zZXJ2ZXJMb2dvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5sZXQgd2wgPSBuZXcgV2ViTG9naW4oKTtcclxuY29uc29sZS5sb2cod2wucGFyc2VFeHBpcmVzKDUwKSk7XHJcbmNvbnNvbGUubG9nKHdsLnBhcnNlRXhwaXJlcygnVGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVEMnKSk7IiwiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpXHJcbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkL3YxJylcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXHJcblxyXG5jb25zdCBwb3J0ID0gMzAwMFxyXG5jb25zdCBpcCA9ICdsb2NhbGhvc3QnXHJcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpXHJcbmNvbnN0IHVzZXJzID0ge1xyXG4gIFwiR3Vpb25hcmRvXCI6IHtcclxuICAgIHBhc3M6IFwiMTIzNFwiLCBhcmdzOiB7IG5vbWU6IFwiR3Vpb25hcmRvIEZ1cmxhblwiLCBpZGFkZTogNDIgfVxyXG4gIH0sXHJcbiAgXCJNYXJpbmVzXCI6IHtcclxuICAgIHBhc3M6IFwiNTY3OFwiLCBhcmdzOiB7IG5vbWU6IFwiTWFyaW5lcyBkb3MgU2FudG9zIEZ1cmxhblwiLCBpZGFkZTogNDEgfVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgdG9rZW5zID0ge31cclxuXHJcbmNvbnN0IHNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xyXG4gIHZhciB1cmxfcGFydHMgPSB1cmwucGFyc2UocmVxLnVybCwgdHJ1ZSk7XHJcblxyXG4gIHZhciBwYXJ0cyA9IHVybF9wYXJ0cy5xdWVyeTtcclxuICB2YXIgcmVzcG9zdGEgPSB7XHJcbiAgICBPSzogZmFsc2UsXHJcbiAgICBNU0c6ICcnLFxyXG4gICAgRlVOQzogJycsXHJcbiAgICBUT0tFTjogJycsXHJcbiAgICBVU0VSREFUQToge31cclxuICB9XHJcblxyXG4gIGxldCBmdW5jID0gKHR5cGVvZiAocGFydHNbJ2xvZ2luJ10pICE9ICd1bmRlZmluZWQnID8gJ2xvZ2luJyA6XHJcbiAgICB0eXBlb2YgKHBhcnRzWydsb2dvdXQnXSkgIT0gJ3VuZGVmaW5lZCcgPyAnbG9nb3V0JyA6XHJcbiAgICAgIHR5cGVvZiAocGFydHNbJ2NoZWNrJ10pICE9ICd1bmRlZmluZWQnID8gJ2NoZWNrJyA6IGZhbHNlKTtcclxuXHJcbiAgaWYgKCFmdW5jKSB7XHJcbiAgICB2YXIgYXJxdWl2byA9ICcuJyArIHVybF9wYXJ0cy5wYXRoO1xyXG4gICAgaWYgKGFycXVpdm8gPT0gJy4vJykgeyBhcnF1aXZvID0gJy4vaW5kZXguaHRtbCc7IH1cclxuICAgIGNvbnNvbGUubG9nKGFycXVpdm8pO1xyXG4gICAgZnMuZXhpc3RzKGFycXVpdm8sIChleGlzdHMpID0+IHtcclxuICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZnMucmVhZEZpbGUoYXJxdWl2bywgZnVuY3Rpb24gKGVyciwgaHRtbCkge1xyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgcmVzLmVuZCgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJxdWl2by5zdWJzdHIoLTMpID09PSBcIi5qc1wiKSB7XHJcbiAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvamF2YXNjcmlwdFwiIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9odG1sXCIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcy53cml0ZShodG1sKTtcclxuICAgICAgICByZXMuZW5kKCk7XHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHJlc3Bvc3RhLkZVTkMgPSBmdW5jO1xyXG5cclxuICBzd2l0Y2ggKGZ1bmMpIHtcclxuICAgIGNhc2UgJ2xvZ2luJzpcclxuICAgICAgLy8jIyMgU29saWNpdGHDp8OjbyBkZSBsb2dpbiBwYXJhIG8gdXN1w6FyaW8gY29tIHNlbmhhIChQT1NUKVxyXG4gICAgICAvLyh1cmwpP2xvZ2luJnVzZXI9dXNlck5hbWUmcGFzcz11c2VyUGFzc3dvcmRcclxuICAgICAgaWYgKHBhcnRzWyd1c2VyJ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3Bvc3RhLk1TRyA9ICdQQVJBTUVURVIgTk9UIEZPVU5EIHVzZXInXHJcbiAgICAgIH0gZWxzZSBpZiAocGFydHNbJ3Bhc3MnXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVzcG9zdGEuTVNHID0gJ1BBUkFNRVRFUiBOT1QgRk9VTkQgcGFzcydcclxuICAgICAgfSBlbHNlIGlmICh1c2Vyc1twYXJ0c1sndXNlciddXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVzcG9zdGEuTVNHID0gJ1VTRVIgTk9UIEZPVU5EICcgKyBwYXJ0c1sndXNlciddXHJcbiAgICAgIH0gZWxzZSBpZiAodXNlcnNbcGFydHNbJ3VzZXInXV0ucGFzcyAhPSBwYXJ0c1sncGFzcyddKSB7XHJcbiAgICAgICAgcmVzcG9zdGEuTVNHID0gJ1BBU1NXT1JEIEVSUk9SJ1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciB0b2tlbiA9IHV1aWQoKTtcclxuICAgICAgICB0b2tlbnNbdG9rZW5dID0gcGFydHNbJ3VzZXInXTtcclxuICAgICAgICByZXNwb3N0YS5NU0cgPSAnT0snO1xyXG4gICAgICAgIHJlc3Bvc3RhLk9LID0gdHJ1ZTtcclxuICAgICAgICByZXNwb3N0YS5UT0tFTiA9IHRva2VuO1xyXG4gICAgICAgIHJlc3Bvc3RhLlVTRVJEQVRBID0gdXNlcnNbdG9rZW5zW3Rva2VuXV0uYXJncztcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2xvZ291dCc6XHJcbiAgICAgIC8vIyMjIFNvbGljaXRhw6fDo28gZGUgbG9nb3V0IHBhcmEgbyB1c3XDoXJpbyAoR0VUKVxyXG4gICAgICAvLyh1cmwpP2xvZ291dCZ0b2tlbj1sb2dpblRva2VuXHJcbiAgICAgIGlmIChwYXJ0c1sndG9rZW4nXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVzcG9zdGEuTVNHID0gJ1BBUkFNRVRFUiBOT1QgRk9VTkQgdG9rZW4nXHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIGlmICh0b2tlbnNbcGFydHNbJ3Rva2VuJ11dID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgIHRva2Vuc1twYXJ0c1sndG9rZW4nXV0gPT09IG51bGwpIHtcclxuICAgICAgICAgIHJlc3Bvc3RhLk1TRyA9ICdUT0tFTiBOT1QgRk9VTkQgJyArIHBhcnRzWyd0b2tlbiddXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRva2Vuc1twYXJ0c1sndG9rZW4nXV0gPSBudWxsXHJcbiAgICAgICAgICByZXNwb3N0YS5NU0cgPSAnVE9LRU4gT0snO1xyXG4gICAgICAgICAgcmVzcG9zdGEuVE9LRU4gPSBwYXJ0c1sndG9rZW4nXVxyXG4gICAgICAgICAgcmVzcG9zdGEuT0sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnY2hlY2snOlxyXG4gICAgICAvLyMjIyBTb2xpY2l0YcOnw6NvIGRlIHZhbGlkYWRlIGRvIHRva2VuIChHRVQpXHJcbiAgICAgIC8vKHVybCk/Y2hlY2smdG9rZW49bG9naW5Ub2tlblxyXG4gICAgICBpZiAocGFydHNbJ3Rva2VuJ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3Bvc3RhLk1TRyA9ICdQQVJBTUVURVIgTk9UIEZPVU5EIHRva2VuJ1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICBpZiAodG9rZW5zW3BhcnRzWyd0b2tlbiddXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXNwb3N0YS5NU0cgPSAnVE9LRU4gTk9UIEZPVU5EICcgKyBwYXJ0c1sndG9rZW4nXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNwb3N0YS5UT0tFTiA9IHBhcnRzWyd0b2tlbiddXHJcbiAgICAgICAgICByZXNwb3N0YS5NU0cgPSAnVE9LRU4gT0snO1xyXG4gICAgICAgICAgcmVzcG9zdGEuT0sgPSB0cnVlO1xyXG4gICAgICAgICAgcmVzcG9zdGEuVVNFUkRBVEEgPSB1c2Vyc1t0b2tlbnNbcGFydHNbJ3Rva2VuJ11dXS5hcmdzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuXHJcbiAgfVxyXG5cclxuXHJcbiAgcmVzLmVuZChKU09OLnN0cmluZ2lmeShyZXNwb3N0YSkpO1xyXG59KVxyXG5cclxuXHJcbnNlcnZlci5saXN0ZW4ocG9ydCwgaXAsICgpID0+IHtcclxuICBjb25zb2xlLmxvZyhgU2Vydmlkb3Igcm9kYW5kbyBlbSBodHRwOi8vJHtpcH06JHtwb3J0fWApO1xyXG59KVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbmZ1bmN0aW9uIHRlc3REYXRlKCl7XHJcbiAgdmFyIGQgPSBEYXRlLnBhcnNlKCdUaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQycpO1xyXG4gIGNvbnNvbGUubG9nKGQpOyAgXHJcbiAgbGV0IGUgPSBuZXcgRGF0ZShkKTtcclxuICBjb25zb2xlLmxvZyhlLnRvVVRDU3RyaW5nKCkpO1xyXG5cclxuICBkID0gRGF0ZS5wYXJzZSgnVHVlLCAyNiBNYXIgMjAxOSAxNDozNDowMCBVVEMnKTtcclxuICBjb25zb2xlLmxvZyhkKTsgIFxyXG4gIGUgPSBuZXcgRGF0ZShkKTtcclxuICBjb25zb2xlLmxvZyhlLnRvVVRDU3RyaW5nKCkpXHJcblxyXG4gIFxyXG4gIGQgPSBuZXcgRGF0ZSgxNTUzNjEwODQwMDAwKTtcclxuICBjb25zb2xlLmxvZyhkKTsgIFxyXG4gIGUgPSBuZXcgRGF0ZShkKTtcclxuICBjb25zb2xlLmxvZyhlLnRvVVRDU3RyaW5nKCkpXHJcbn1cclxuXHJcbnRlc3REYXRlKCk7Il19